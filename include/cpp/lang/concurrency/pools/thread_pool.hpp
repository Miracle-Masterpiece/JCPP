#ifndef JSTD_CPP_LANG_CONCURRENCY_THREAD_POOL_H
#define JSTD_CPP_LANG_CONCURRENCY_THREAD_POOL_H

#include <cstdint>
#include <cpp/lang/concurrency/cond_var.hpp>

namespace jstd
{

namespace concurrency
{

/**
 * Абстрактная асинхронная задача для исполнения в пуле потоков.
 *
 * Класс представляет собой базовый интерфейс для любой задачи, которую
 * можно отправить в потоковый пул. 
 * Содержит встроенную синхронизацию, отслеживание завершения и возможность сброса состояния (если поддерживается).
 *
 * Поддерживает копирование и перемещение. При этом создаются новые внутренние
 * объекты синхронизации, но флаг завершённости (m_is_done) копируется.
 * Это означает, что копия задачи не синхронизирована с оригиналом.
 *
 * Вызов join() безопасен до или после начала выполнения.
 * Метод reset() можно переопределить для повторного использования задачи, 
 * но базовая реализация должна вызываться обязательно.
 */
class task {
    mutex       m_mutex;
    cond_var    m_cond_var;
    bool        m_is_done;
public:
    /**
     *Конструктор по умолчанию.
     *
     * Создаёт новую задачу с флагом m_is_done == false.
     */
    task();

    /**
     * Копирующий конструктор.
     *
     * Копирует флаг завершения, но создаёт новые объекты синхронизации.
     *
     * @param other 
     *      Задача для копирования.
     */
    task(const task& other);

    /**
     * Перемещающий конструктор.
     *
     * Перемещает флаг m_is_done, но также создаёт собственные
     * мьютекс и условную переменную.
     *
     * @param other 
     *      Задача, из которой происходит перемещение.
     */
    task(task&& other);

    /**
     * Оператор копирующего присваивания.
     *
     * Копирует флаг завершения. Сброс синхронизации не требуется,
     * так как каждая задача владеет собственными мьютексами.
     *
     * @param other 
     *      Задача для копирования.
     * 
     * @return *this
     */
    task& operator=(const task& other);

    /**
     * Оператор перемещающего присваивания.
     *
     * Перемещает флаг завершения, создавая при этом свои объекты
     * синхронизации.
     *
     * @param other 
     *      Задача, из которой перемещается.
     * 
     * @return *this
     */
    task& operator=(task&& other);

    /**
     * Выполняет задачу.
     *
     * Чисто виртуальная функция, которую должен реализовать пользователь.
     * После завершения необходимо вызвать set_done(true) для
     * уведомления ожидающих потоков.
     */
    virtual void execute() = 0;

    /**
     * Сброс состояния задачи.
     *
     * Если m_is_done == false, выбрасывает illegal_state_exception.
     * Базовая реализация сбрасывает флаг m_is_done = false.
     * Наследник может переопределить метод, но обязан вызвать реализацию
     * базового класса.
     *
     * Если задача не поддерживает повторное выполнение, должна быть добавлена
     * проверка is_resetable() и выброшено unsupported_operation_exception.
     *
     * @throws illegal_state_exception 
     *      Eсли задача ещё не завершена.
     * 
     * @throws unsupported_operation_exception 
     *      Eсли сброс не поддерживается.
     */
    virtual void reset();

    /**
     */
    virtual ~task() = 0;

    /**
     * Проверяет, завершена ли задача.
     *
     * @return 
     *      true, если set_done(true) был вызван.
     */
    bool is_done();

    /**
     * Устанавливает флаг завершения задачи.
     *
     * Метод потокобезопасен и уведомляет все потоки, ожидающие через join().
     * Обычно вызывается из реализации thread_pool после завершения вызова execute().
     * Не предназначен для прямого использования со стороны пользователя задачи.
     *
     * @param is_done 
     *      Новое значение флага завершения.
     */
    void set_done(bool is_done);

    /**
     * Блокирует вызывающий поток до завершения задачи.
     *
     * Если задача уже завершена, метод сразу возвращает.
     * Может безопасно вызываться до начала выполнения.
     * Гарантирует, что вызывающий поток дождётся вызова set_done(true).
     */
    void join();
};


/**
 * Абстрактный интерфейс пула потоков для асинхронного выполнения задач.
 *
 * Интерфейс thread_pool определяет API для систем многозадачности, позволяя
 * отправлять задачи (task) на исполнение, останавливать выполнение и ожидать завершения всех операций.
 *
 * После вызова shutdown() или force_shutdown() пул считается завершённым и
 * больше не может использоваться для новых задач. 
 * Попытки отправки задач после этого приведут к выбросу illegal_state_exception.
 *
 * Потокобезопасность и параллелизм исполнения задач обеспечиваются реализацией.
 */
class thread_pool {
public:
    /**
     * Отправляет задачу на выполнение.
     *
     * Ожидается, что указатель task* валиден и не равен nullptr.
     * Пул сохраняет задачу в очереди до выполнения.
     *
     * Если пул уже был остановлен (shutdown() или force_shutdown()),
     * выбрасывается illegal_state_exception.
     *
     * @param t 
     *      Указатель на задачу для исполнения.
     * 
     * @throws illegal_state_exception 
     *      Eсли пул уже остановлен.
     * 
     * @throws illegal_argument_exception 
     *      Eсли t == nullptr.
     */
    virtual void submit(task* t) = 0;

    /**
     * Отправляет массив задач на выполнение.
     *
     * Каждая задача из массива помещается в очередь на исполнение.
     *
     * @param tasks 
     *      Указатель на массив указателей задач.
     * 
     * @param bufsize 
     *      Количество элементов в массиве. Должно быть > 0.
     *
     * @throws illegal_state_exception 
     *      Eсли пул уже остановлен.
     * 
     * @throws illegal_argument_exception 
     *      Eсли tasks == nullptr. 
     *      Если bufsize <= 0.
     */
    virtual void submit(task* tasks[], int32_t bufsize) = 0;

    /**
     * Плавно завершает работу пула.
     *
     * Больше не принимает новые задачи, но выполняет уже отправленные.
     * Все рабочие потоки завершаются после выполнения своих текущих задач.
     *
     * Повторный вызов безопасен, но не имеет эффекта.
     */
    virtual void shutdown() = 0;

    /**
     * Принудительно завершает работу пула.
     *
     * Удаляет все задачи из очереди, запрещает приём новых задач
     * и завершает рабочие потоки после выполнения текущей задачи (если выполняется).
     *
     * Повторный вызов безопасен.
     */
    virtual void force_shutdown() = 0;

    /**
     * Ожидает завершения всех потоков.
     *
     * Метод блокирует вызывающий поток до тех пор, пока все рабочие потоки
     * не завершат выполнение. Если shutdown() или force_shutdown() не были
     * вызваны, то метод не вернётся (возможен дедлок, если ни один из существующих потоков программы не вызовет функции shutdown() или force_shutdown()).
     *
     * Рекомендуется сначала вызвать остановку пула.
     */
    virtual void join_all() = 0;

    /**
     * Возвращает следующую задачу из очереди.
     *
     * Метод предназначен исключительно для внутреннего использования реализацией пула.
     * Пользователю вызывать его не следует.
     *
     * Возвращает задачу из очереди или nullptr, если очередь пуста.
     * Может блокировать вызывающий поток в зависимости от реализации.
     *
     * @return 
     *      Задача на исполнение или nullptr.
     */
    virtual task* get_task() = 0;

    /**
     * Виртуальный деструктор.
     *
     * Гарантирует корректное уничтожение объектов при наследовании.
     */
    virtual ~thread_pool() {}
};


}//namespace concurrency


}//namespace jstd

#endif//JSTD_CPP_LANG_CONCURRENCY_THREAD_POOL_H
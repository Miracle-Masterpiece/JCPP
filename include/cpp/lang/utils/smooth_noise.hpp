#ifndef JSTD_CPP_LANG_UTILS_SMOOTH_NOISE_H
#define JSTD_CPP_LANG_UTILS_SMOOTH_NOISE_H
#include <cpp/lang/array.hpp>
#include <cpp/lang/utils/random.hpp>

namespace jstd
{

/**
 * Генератор двумерного шума с интерполяцией и поддержкой многослойного (фрактального) шума.
 * 
 * Шум создаётся на основе фиксированного массива случайных значений, и значения интерполируются
 * с возможностью дополнительного искривления интерполяционного параметра через функцию {@code curve_func}.
 * 
 * Поддерживается как простой шум, так и шум с несколькими октавами. Все значения шума находятся в диапазоне [0.0, 1.0].
 * 
 */
class smooth_noise {
    int8_t        m_buffer[32];     // Длина должна быть степенью двойки.
    array<int8_t> m_values;         // Обёртка над буфером.
    int64_t       m_seed;           // Сид для генератора.
    float (*m_curve_func)(float x);  // Функция искажения параметра интерполяции.

    /**
     * Возвращает значение шума в заданной целочисленной координате.
     * Использует хеширование координат, результат проецируется на массив значений {@code m_values}.
     * 
     * @param x 
     *      X-координата.
     * 
     * @param y 
     *      Y-координата.
     * 
     * @return 
     *      Значение из массива, приведённое к диапазону [0.0, 1.0].
     */
    float value_at(int64_t x, int64_t y) const;

public:
    /**
     * Тип функции искривления параметра интерполяции {@code t}.
     * При интерполяции между значениями функция {@code curve_func} применяется к параметру {@code t ∈ [0, 1]},
     * чтобы добиться сглаживания (например, quintic-кривые).
     */
    typedef float (*curve_func)(float x);

    /**
     * Создаёт генератор с произвольным сидом и заданной функцией искривления.
     * Массив значений автоматически инициализируется.
     *
     * @param curve Функция искривления интерполяционного параметра {@code t}. По умолчанию — {@code no_smooth()}.
     */
    smooth_noise(curve_func curve = no_smooth);

    /**
     * Создаёт генератор с заданным сидом и функцией искривления.
     * Массив значений автоматически инициализируется.
     *
     * @param seed 
     *      Начальное значение генератора.
     * 
     * @param curve 
     *      Функция искривления интерполяционного параметра.
     */
    smooth_noise(int64_t seed, curve_func curve = no_smooth);

    /** Конструктор копирования. */
    smooth_noise(const smooth_noise& other);

    /** Конструктор перемещения. */
    smooth_noise(smooth_noise&& other);

    /** Оператор копирующего присваивания. */
    smooth_noise& operator=(const smooth_noise& other);

    /** Оператор перемещающего присваивания. */
    smooth_noise& operator=(smooth_noise&& other);

    /** Деструктор. */
    ~smooth_noise();

    /**
     * Возвращает текущий сид генератора.
     *
     * @return 
     *      Значение сида.
     */
    int64_t get_seed() const;

    /**
     * Устанавливает новое значение сида.
     * Для обновления данных вызовите {@code generate_values()}.
     *
     * @param seed 
     *      Новое значение сида.
     */
    void set_seed(int64_t seed);

    /**
     * Заполняет массив значений случайными числами на основе текущего сида.
     * Каждое значение будет от {@code 0} до {@code num_limits<int8_t>::max()}.
     */
    void generate_values();

    /**
     * Возвращает сглаженное значение шума в координатах (x, y) при заданном масштабе.
     * 
     * Координаты сначала делятся на {@code scale}, затем интерполируются с использованием
     * функции сглаживания {@code curve_func}.
     * 
     * @param x 
     *      X-координата.
     * 
     * @param y 
     *      Y-координата.
     * 
     * @param scale 
     *      Масштаб выборки (должен быть > 0). 
     *      Если масштаб равен нулю, то функция возвращает 0.
     * 
     * @return 
     *      Значение шума в диапазоне [0.0, 1.0].
     */
    float get(int64_t x, int64_t y, int64_t scale) const;

    /**
     * Возвращает значение многослойного (фрактального) шума.
     * Каждая октава добавляет слой шума с другой амплитудой и частотой.
     * {@code scale_factor} — затухание амплитуды от октавы к октаве.
     * {@code freeq_factor} — увеличение частоты от октавы к октаве.
     * 
     * Результат — средневзвешенное значение от всех слоёв.
     * 
     * @param x 
     *      X-координата.
     * 
     * @param y 
     *      Y-координата.
     * 
     * @param scale 
     *      Базовый масштаб.
     * 
     * @param octaves 
     *      Количество октав (должно быть > 0).
     * 
     * @param scale_factor 
     *      Коэффициент амплитудного затухания между октавами (>= 0).
     * 
     * @param freeq_factor 
     *      Коэффициент увеличения частоты между октавами (>= 0).
     * 
     * @return 
     *      Значение шума в диапазоне [0.0, 1.0].
     * 
     * @throws illegal_argument_exception 
     *      Если scale <= 0.
     *      Если octaves <= 0.
     *      Если scale_factor < 0.
     *      Если freeq_factor < 0.
     */
    float get(int64_t x, int64_t y, int64_t scale, int32_t octaves, float scale_factor = 0.5f, float freeq_factor = 0.5f) const;

    /**
     * Простая функция без сглаживания.
     * Возвращает x без изменений. 
     * 
     * @param x 
     *      Параметр интерполяции {@code t}.
     * 
     * @return x
     */
    static float no_smooth(float x);

    /**
     * Устанавливает новую функцию искривления параметра интерполяции.
     * Функция должна принимать значение {@code t ∈ [0, 1]} и возвращать тоже в этом диапазоне.
     *
     * @param func 
     *      Функция, применяемая при интерполяции.
     */
    void set_curve_fuc(curve_func func);
};


}

#endif//JSTD_CPP_LANG_UTILS_SMOOTH_NOISE_H
#ifndef _ALLOCATORS_SYSTEM_H
#define _ALLOCATORS_SYSTEM_H

#include <cstdint>

namespace jstd 
{

enum byte_order {
    LE, //little-endian
    BE, //big-endian
};

namespace system 
{

namespace internal
{
    /**
     * Системный порядок байт.
     * */    
    extern const byte_order system_order;
}


    /**
     * Возвращает константу порядка байтов на выполняемой системе.
     * 
     * @return
     *      byte_order::LE - если программа выполняется на процессоре с порядом байтов Little-Endian
     *      byte_order::BE - если программа выполняется на процессоре с порядом байтов Big-Endian
     */
    inline byte_order native_byte_order() {
        return internal::system_order;
    }

    inline bool native_is_little_endian() {
        return native_byte_order() == byte_order::LE;
    }

    inline bool native_is_big_endian() {
        return native_byte_order() == byte_order::BE;
    }

    /**
     * Возвращает текущее время в миллисекундах, прошедших с начала Unix-эпохи (1 января 1970 года).
     * Функция предоставляет кросс-платформенный способ получения времени, работая на Linux, macOS и Windows.
     * 
     * На Linux и macOS используется системный вызов `gettimeofday`, который возвращает время с высокой точностью.
     * На Windows время извлекается из структуры `FILETIME`, которая отсчитывает время с 1 января 1601 года.
     * Для приведения к Unix-эпохе выполняется корректировка с использованием константы 11644473600000.
     * 
     * @return int64_t — количество миллисекунд, прошедших с начала Unix-эпохи.
     * 
     * @note На Windows время изначально представлено в 100-наносекундных интервалах.
     *       Для перевода в миллисекунды значение делится на 10000.
     * 
     * @warning Время, возвращаемое функцией, зависит от системных часов.
     *          Изменение системного времени может повлиять на результат.
     */
    int64_t current_time_millis();

    /**
     * Возвращает текущее время в секундах, прошедших с начала Unix-эпохи (1 января 1970 года).
     * Функция использует результат `current_time_millis()` и делит его на 1000 для получения времени в секундах.
     * 
     * @return int64_t — количество секунд, прошедших с начала Unix-эпохи.
     * 
     * @note Функция возвращает целое число секунд, отбрасывая дробную часть.
     *       Для более точного измерения времени используйте `current_time_millis()`.
     * 
     * @warning Время, возвращаемое функцией, зависит от системных часов.
     *          Изменение системного времени может повлиять на результат.
     */
    int64_t current_time_seconds();

    /**
     * Возвращает текущее время в наносекундах, используя монотонные часы.
     * Монотонные часы не подвержены изменениям системного времени и идеально подходят для измерения интервалов.
     * 
     * На Linux и macOS используется системный вызов `clock_gettime` с флагом `CLOCK_MONOTONIC`,
     * который возвращает время, прошедшее с момента запуска системы.
     * На Windows время измеряется с помощью высокоточного таймера `QueryPerformanceCounter`,
     * который считает такты процессора. Для перевода тактов в наносекунды используется частота таймера.
     * 
     * @return int64_t — количество наносекунд, прошедших с момента, определённого системой как начало отсчёта.
     * 
     * @note На Windows частота таймера может варьироваться в зависимости от оборудования.
     *       Функция автоматически учитывает это при расчёте времени.
     * 
     * @warning Возвращаемое значение не привязано к календарному времени.
     *          Оно предназначено исключительно для измерения интервалов.
     */
    int64_t nano_time();

    /**
     * Возвращает описание системной ошибки.
     */
    const char* error_string(int err);

    /**
     * Thread-Safe printf
     */
    int tsprintf(const char* format, ...);

}//namespace system

}//namespace jstd

#endif//_ALLOCATORS_SYSTEM_H